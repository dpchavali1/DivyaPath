package com.divyapath.app.audio;

import android.content.Context;
import android.media.AudioAttributes;
import android.media.AudioFocusRequest;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.speech.tts.TextToSpeech;
import android.speech.tts.UtteranceProgressListener;
import android.speech.tts.Voice;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.divyapath.app.R;
import com.divyapath.app.utils.PreferenceManager;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Enhanced TTS engine for devotional content with:
 *   - Edge TTS (Microsoft Neural Voices) for natural-sounding speech — free, no API key
 *   - Fallback to Android system TTS when Edge TTS unavailable
 *   - Verse-aware pacing (section headers, verse markers, refrain detection)
 *   - Smart ducking (background music auto-lowers when TTS speaks)
 *   - Optional background Om drone mixing
 *   - Audio preset support (clarity/night mode)
 *
 * Playback modes:
 *   MODE_CLOUD  — Plays cached MP3 files generated by Edge TTS via MediaPlayer
 *   MODE_SYSTEM — Uses Android's built-in TextToSpeech engine (legacy fallback)
 */
public class DivyaPathTTSEngine {

    private static final String TAG = "DivyaPathTTSEngine";
    private static final float DEVOTIONAL_SPEECH_RATE = 0.72f;

    // Background music volumes
    private static final float BG_MUSIC_NORMAL = 0.15f;
    private static final float BG_MUSIC_DUCKED = 0.04f;
    private static final long DUCK_FADE_MS = 300;

    // Verse-aware pause durations (milliseconds)
    private static final long PAUSE_SECTION_HEADER = 1200;
    private static final long PAUSE_VERSE_END = 800;
    private static final long PAUSE_STANZA_BREAK = 600;
    private static final long PAUSE_NORMAL_LINE = 500;
    private static final long PAUSE_REFRAIN = 300;

    // Lookahead lines to pre-generate for Cloud TTS
    private static final int CLOUD_TTS_LOOKAHEAD = 3;

    private enum PlaybackMode { CLOUD, SYSTEM }

    private final Context appContext;
    private final PreferenceManager preferences;
    private final AudioManager audioManager;
    private TextToSpeech tts;
    private MediaPlayer bgPlayer;
    private MediaPlayer cloudPlayer; // For playing Cloud TTS audio files
    private CloudTtsService cloudTtsService;
    private boolean ttsInitialized = false;
    private boolean speaking = false;
    private String[] lines;
    private int currentLineIndex = 0;
    private boolean bgMusicEnabled = true;
    private String lastRefrain = null;
    private String contentType = null;

    // Playback mode
    private PlaybackMode playbackMode = PlaybackMode.SYSTEM;

    // Audio preset state
    private String currentPreset = "normal"; // "normal", "clarity", "night"

    // Audio focus for smart ducking
    private AudioFocusRequest audioFocusRequest;

    // Background thread for Cloud TTS API calls
    private final ExecutorService cloudTtsExecutor = Executors.newSingleThreadExecutor();

    // LiveData for UI
    private final MutableLiveData<Boolean> isPlaying = new MutableLiveData<>(false);
    private final MutableLiveData<Integer> currentLine = new MutableLiveData<>(0);
    private final MutableLiveData<Boolean> isReady = new MutableLiveData<>(false);
    private final MutableLiveData<String> statusText = new MutableLiveData<>("AI Voice");

    private final Handler handler = new Handler(Looper.getMainLooper());
    private final Handler bgVolumeHandler = new Handler(Looper.getMainLooper());

    private OnTtsEventListener eventListener;

    public interface OnTtsEventListener {
        void onLineStarted(int lineIndex, String lineText);
        void onLineCompleted(int lineIndex);
        void onCompleted();
        void onError(String message);
    }

    public DivyaPathTTSEngine(@NonNull Context context) {
        this.appContext = context.getApplicationContext();
        this.preferences = new PreferenceManager(appContext);
        this.audioManager = (AudioManager) appContext.getSystemService(Context.AUDIO_SERVICE);
        this.cloudTtsService = new CloudTtsService(appContext);
        initTts();
    }

    private void initTts() {
        tts = new TextToSpeech(appContext, status -> {
            if (status == TextToSpeech.SUCCESS) {
                setupVoice();
                ttsInitialized = true;
                isReady.postValue(true);
                setupUtteranceListener();
            } else {
                Log.e(TAG, "TTS initialization failed");
                // Cloud TTS may still work even if system TTS fails
                if (cloudTtsService.isAvailable()) {
                    isReady.postValue(true);
                } else {
                    statusText.postValue("TTS unavailable");
                }
            }
        });
    }

    private void setupVoice() {
        Locale hindi = new Locale("hi", "IN");
        int result = tts.setLanguage(hindi);
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
            tts.setLanguage(new Locale("hi"));
        }

        String preferredGender = preferences.getVoiceGender();

        try {
            Set<Voice> voices = tts.getVoices();
            if (voices != null) {
                Voice bestVoice = null;
                int bestScore = -1;

                for (Voice voice : voices) {
                    if (!voice.getLocale().getLanguage().equals("hi")) continue;

                    int score = 0;
                    String name = voice.getName().toLowerCase();
                    if ("IN".equals(voice.getLocale().getCountry())) score += 10;
                    score += voice.getQuality();
                    if (!voice.isNetworkConnectionRequired()) score += 50;

                    boolean isMale = name.contains("male") || name.contains("-m-") || name.contains("_m_");
                    boolean isFemale = name.contains("female") || name.contains("-f-") || name.contains("_f_");

                    if (preferredGender.equals("male") && isMale) score += 100;
                    else if (preferredGender.equals("female") && isFemale) score += 100;
                    else if (preferredGender.equals("female") && !isMale) score += 20;
                    else if (preferredGender.equals("male") && !isFemale) score += 20;

                    if (score > bestScore) {
                        bestScore = score;
                        bestVoice = voice;
                    }
                }

                if (bestVoice != null) {
                    tts.setVoice(bestVoice);
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Voice selection failed", e);
        }

        applyPresetToTts();
    }

    private void applyPresetToTts() {
        switch (currentPreset) {
            case "clarity":
                tts.setSpeechRate(DEVOTIONAL_SPEECH_RATE * 0.9f);
                tts.setPitch(preferences.getVoiceGender().equals("male") ? 0.95f : 1.1f);
                break;
            case "night":
                tts.setSpeechRate(DEVOTIONAL_SPEECH_RATE * 0.8f);
                tts.setPitch(preferences.getVoiceGender().equals("male") ? 0.75f : 0.9f);
                break;
            default:
                tts.setSpeechRate(DEVOTIONAL_SPEECH_RATE);
                tts.setPitch(preferences.getVoiceGender().equals("male") ? 0.85f : 1.0f);
                break;
        }
    }

    private void setupUtteranceListener() {
        tts.setOnUtteranceProgressListener(new UtteranceProgressListener() {
            @Override
            public void onStart(String utteranceId) {
                speaking = true;
                isPlaying.postValue(true);
                duckBgMusic();
                if (eventListener != null) {
                    handler.post(() -> eventListener.onLineStarted(currentLineIndex,
                            lines != null && currentLineIndex < lines.length ? lines[currentLineIndex] : ""));
                }
            }

            @Override
            public void onDone(String utteranceId) {
                unduckBgMusic();

                if (eventListener != null) {
                    handler.post(() -> eventListener.onLineCompleted(currentLineIndex));
                }

                int completedIndex = currentLineIndex;
                currentLineIndex++;
                currentLine.postValue(currentLineIndex);

                if (currentLineIndex < (lines != null ? lines.length : 0) && speaking) {
                    long pauseMs = computePauseDuration(completedIndex);
                    try { Thread.sleep(pauseMs); } catch (InterruptedException ignored) {}
                    speakCurrentLine();
                } else {
                    speaking = false;
                    isPlaying.postValue(false);
                    stopBgMusic();
                    releaseAudioFocus();
                    currentLineIndex = 0;
                    currentLine.postValue(0);
                    if (eventListener != null) {
                        handler.post(() -> eventListener.onCompleted());
                    }
                }
            }

            @Override
            public void onError(String utteranceId) {
                speaking = false;
                isPlaying.postValue(false);
                unduckBgMusic();
                stopBgMusic();
                releaseAudioFocus();
                if (eventListener != null) {
                    handler.post(() -> eventListener.onError("TTS error on line " + currentLineIndex));
                }
            }
        });
    }

    // --- Verse-aware Pacing ---

    private long computePauseDuration(int completedLineIndex) {
        if (lines == null || completedLineIndex < 0 || completedLineIndex >= lines.length) {
            return PAUSE_NORMAL_LINE;
        }

        String completedLine = lines[completedLineIndex];
        String nextLine = (completedLineIndex + 1 < lines.length) ? lines[completedLineIndex + 1] : null;

        if (nextLine != null && isSectionHeader(nextLine)) return PAUSE_SECTION_HEADER;
        if (isSectionHeader(completedLine)) return PAUSE_SECTION_HEADER;
        if (isVerseEndMarker(completedLine)) return PAUSE_VERSE_END;
        if (isRefrain(completedLine)) return PAUSE_REFRAIN;
        if (completedLine.endsWith("॥") || completedLine.endsWith("।।")) return PAUSE_STANZA_BREAK;

        return PAUSE_NORMAL_LINE;
    }

    private boolean isSectionHeader(String line) {
        String stripped = line.replaceAll("[॥।\\|\\s]", "").trim();
        return stripped.equalsIgnoreCase("दोहा") || stripped.equalsIgnoreCase("चौपाई") ||
               stripped.equalsIgnoreCase("सोरठा") || stripped.equalsIgnoreCase("छन्द") ||
               stripped.equalsIgnoreCase("अर्धाली") || stripped.equalsIgnoreCase("Doha") ||
               stripped.equalsIgnoreCase("Chaupai");
    }

    private boolean isVerseEndMarker(String line) {
        return line.matches(".*॥\\s*\\d+\\s*॥\\s*$") ||
               line.matches("^[॥।\\|\\s\\d०-९]+$");
    }

    private boolean isRefrain(String line) {
        if (lastRefrain != null && line.trim().equals(lastRefrain.trim())) return true;
        if (lines != null && currentLineIndex > 3) {
            for (int i = 0; i < Math.min(3, lines.length); i++) {
                if (lines[i].trim().equals(line.trim())) {
                    lastRefrain = line;
                    return true;
                }
            }
        }
        return false;
    }

    // --- Public API ---

    public void setText(@Nullable String text) {
        if (text != null) {
            String[] rawLines = text.split("\n");
            List<String> filtered = new ArrayList<>();
            for (String line : rawLines) {
                String trimmed = line.trim();
                if (!trimmed.isEmpty()) {
                    filtered.add(trimmed);
                }
            }
            this.lines = filtered.toArray(new String[0]);
        } else {
            this.lines = new String[0];
        }
        currentLineIndex = 0;
        currentLine.postValue(0);
        lastRefrain = null;
    }

    /**
     * Set the content type for Cloud TTS SSML profile selection.
     */
    public void setContentType(@Nullable String contentType) {
        this.contentType = contentType;
    }

    public void play() {
        if (lines == null || lines.length == 0) return;

        // Determine playback mode: prefer Cloud TTS if available
        if (cloudTtsService.isAvailable()) {
            playbackMode = PlaybackMode.CLOUD;
            speaking = true;
            statusText.postValue("Natural Voice reading...");
            requestAudioFocus();
            if (bgMusicEnabled) {
                startBgMusic();
            }
            // Pre-generate lookahead lines and start playing
            preGenerateAndPlay();
        } else if (ttsInitialized) {
            playbackMode = PlaybackMode.SYSTEM;
            setupVoice();
            speaking = true;
            statusText.postValue("AI Voice reading...");
            requestAudioFocus();
            if (bgMusicEnabled) {
                startBgMusic();
            }
            speakCurrentLine();
        }
    }

    public void pause() {
        speaking = false;
        if (playbackMode == PlaybackMode.CLOUD) {
            stopCloudPlayer();
        } else {
            if (tts != null) tts.stop();
        }
        isPlaying.postValue(false);
        pauseBgMusic();
        statusText.postValue(playbackMode == PlaybackMode.CLOUD
                ? "Natural Voice paused" : "AI Voice paused");
    }

    public void stop() {
        speaking = false;
        if (playbackMode == PlaybackMode.CLOUD) {
            stopCloudPlayer();
        } else {
            if (tts != null) tts.stop();
        }
        isPlaying.postValue(false);
        stopBgMusic();
        releaseAudioFocus();
        currentLineIndex = 0;
        currentLine.postValue(0);
        statusText.postValue(playbackMode == PlaybackMode.CLOUD
                ? "Natural Voice" : "AI Voice");
    }

    public void togglePlayPause() {
        if (speaking) pause(); else play();
    }

    public void setBgMusicEnabled(boolean enabled) {
        this.bgMusicEnabled = enabled;
        if (!enabled) stopBgMusic();
        else if (speaking) startBgMusic();
    }

    public boolean isBgMusicEnabled() { return bgMusicEnabled; }

    public void setAudioPreset(String preset) {
        this.currentPreset = preset != null ? preset : "normal";
        if (ttsInitialized) applyPresetToTts();
        if ("night".equals(preset) && bgPlayer != null) {
            bgPlayer.setVolume(BG_MUSIC_DUCKED, BG_MUSIC_DUCKED);
        }
    }

    public String getAudioPreset() { return currentPreset; }

    public void setEventListener(@Nullable OnTtsEventListener listener) {
        this.eventListener = listener;
    }

    /**
     * Returns whether Cloud TTS is the active playback mode.
     */
    public boolean isCloudTtsActive() {
        return playbackMode == PlaybackMode.CLOUD;
    }

    // --- Cloud TTS Playback ---

    /**
     * Pre-generate audio for upcoming lines and start playback.
     */
    private void preGenerateAndPlay() {
        cloudTtsExecutor.execute(() -> {
            // Pre-generate current line + lookahead
            int endIndex = Math.min(currentLineIndex + CLOUD_TTS_LOOKAHEAD, lines.length);
            for (int i = currentLineIndex; i < endIndex && speaking; i++) {
                String line = lines[i];
                if (line.length() >= 3 && !line.matches("^[॥।\\|\\s\\d०-९]+$")) {
                    cloudTtsService.synthesizeLine(line, contentType);
                }
            }
            // Start playing the current line
            handler.post(this::playCloudCurrentLine);
        });
    }

    /**
     * Play the current line using Cloud TTS audio, with fallback to system TTS.
     */
    private void playCloudCurrentLine() {
        if (!speaking || lines == null || currentLineIndex >= lines.length) return;

        String line = lines[currentLineIndex];

        // Skip pure punctuation/number lines
        if (line.length() < 3 || line.matches("^[॥।\\|\\s\\d०-९]+$")) {
            currentLineIndex++;
            currentLine.postValue(currentLineIndex);
            if (currentLineIndex < lines.length && speaking) {
                handler.postDelayed(this::playCloudCurrentLine, PAUSE_VERSE_END);
            } else {
                onCloudPlaybackComplete();
            }
            return;
        }

        // Try to get cached/synthesized audio
        cloudTtsExecutor.execute(() -> {
            String audioPath = cloudTtsService.synthesizeLine(line, contentType);

            if (audioPath != null && speaking) {
                handler.post(() -> playCloudAudioFile(audioPath));
            } else if (speaking) {
                // Fallback to system TTS for this line
                Log.w(TAG, "Cloud TTS failed for line " + currentLineIndex + ", falling back to system TTS");
                handler.post(() -> {
                    playbackMode = PlaybackMode.SYSTEM;
                    statusText.postValue("AI Voice reading...");
                    speakCurrentLine();
                });
            }

            // Pre-generate next lines in background
            if (speaking) {
                int nextStart = currentLineIndex + 1;
                int nextEnd = Math.min(nextStart + CLOUD_TTS_LOOKAHEAD, lines.length);
                for (int i = nextStart; i < nextEnd && speaking; i++) {
                    String nextLine = lines[i];
                    if (nextLine.length() >= 3 && !nextLine.matches("^[॥।\\|\\s\\d०-९]+$")) {
                        cloudTtsService.synthesizeLine(nextLine, contentType);
                    }
                }
            }
        });
    }

    /**
     * Play an audio file from Cloud TTS through MediaPlayer.
     */
    private void playCloudAudioFile(String filePath) {
        if (!speaking) return;

        stopCloudPlayer();
        duckBgMusic();

        isPlaying.postValue(true);
        if (eventListener != null) {
            eventListener.onLineStarted(currentLineIndex,
                    lines != null && currentLineIndex < lines.length ? lines[currentLineIndex] : "");
        }

        try {
            cloudPlayer = new MediaPlayer();
            cloudPlayer.setAudioAttributes(new AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_MEDIA)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build());
            cloudPlayer.setDataSource(filePath);
            cloudPlayer.setOnCompletionListener(mp -> onCloudLineCompleted());
            cloudPlayer.setOnErrorListener((mp, what, extra) -> {
                Log.e(TAG, "Cloud audio playback error: " + what + "/" + extra);
                onCloudLineCompleted();
                return true;
            });
            cloudPlayer.prepare();
            cloudPlayer.start();
        } catch (IOException e) {
            Log.e(TAG, "Failed to play Cloud TTS audio", e);
            // Fallback to system TTS
            playbackMode = PlaybackMode.SYSTEM;
            statusText.postValue("AI Voice reading...");
            speakCurrentLine();
        }
    }

    /**
     * Called when a Cloud TTS line finishes playing.
     */
    private void onCloudLineCompleted() {
        unduckBgMusic();
        stopCloudPlayer();

        if (eventListener != null) {
            handler.post(() -> eventListener.onLineCompleted(currentLineIndex));
        }

        int completedIndex = currentLineIndex;
        currentLineIndex++;
        currentLine.postValue(currentLineIndex);

        if (currentLineIndex < (lines != null ? lines.length : 0) && speaking) {
            long pauseMs = computePauseDuration(completedIndex);
            handler.postDelayed(this::playCloudCurrentLine, pauseMs);
        } else {
            onCloudPlaybackComplete();
        }
    }

    /**
     * Called when all Cloud TTS lines have been played.
     */
    private void onCloudPlaybackComplete() {
        speaking = false;
        isPlaying.postValue(false);
        stopBgMusic();
        releaseAudioFocus();
        currentLineIndex = 0;
        currentLine.postValue(0);
        if (eventListener != null) {
            handler.post(() -> eventListener.onCompleted());
        }
    }

    private void stopCloudPlayer() {
        try {
            if (cloudPlayer != null) {
                if (cloudPlayer.isPlaying()) cloudPlayer.stop();
                cloudPlayer.release();
                cloudPlayer = null;
            }
        } catch (Exception ignored) {}
    }

    // --- Smart Ducking ---

    private void duckBgMusic() {
        if (bgPlayer != null && bgPlayer.isPlaying()) {
            bgVolumeHandler.post(() -> {
                if (bgPlayer != null) bgPlayer.setVolume(BG_MUSIC_DUCKED, BG_MUSIC_DUCKED);
            });
        }
    }

    private void unduckBgMusic() {
        if (bgPlayer != null && bgPlayer.isPlaying()) {
            float targetVol = "night".equals(currentPreset) ? BG_MUSIC_DUCKED : BG_MUSIC_NORMAL;
            bgVolumeHandler.postDelayed(() -> {
                if (bgPlayer != null) bgPlayer.setVolume(targetVol, targetVol);
            }, DUCK_FADE_MS);
        }
    }

    private void requestAudioFocus() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            AudioAttributes attrs = new AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_MEDIA)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build();
            audioFocusRequest = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
                    .setAudioAttributes(attrs)
                    .setOnAudioFocusChangeListener(focusChange -> {
                        if (focusChange == AudioManager.AUDIOFOCUS_LOSS) stop();
                        else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) pause();
                    })
                    .build();
            audioManager.requestAudioFocus(audioFocusRequest);
        }
    }

    private void releaseAudioFocus() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && audioFocusRequest != null) {
            audioManager.abandonAudioFocusRequest(audioFocusRequest);
            audioFocusRequest = null;
        }
    }

    // --- Background Music ---

    private void startBgMusic() {
        try {
            if (bgPlayer == null) {
                bgPlayer = MediaPlayer.create(appContext, R.raw.om_tone);
                if (bgPlayer == null) return;
                bgPlayer.setAudioAttributes(new AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .build());
                bgPlayer.setLooping(true);
            }
            float vol = "night".equals(currentPreset) ? BG_MUSIC_DUCKED : BG_MUSIC_NORMAL;
            bgPlayer.setVolume(vol, vol);
            if (!bgPlayer.isPlaying()) bgPlayer.start();
        } catch (Exception e) {
            Log.e(TAG, "Background music error", e);
        }
    }

    private void pauseBgMusic() {
        try { if (bgPlayer != null && bgPlayer.isPlaying()) bgPlayer.pause(); } catch (Exception ignored) {}
    }

    private void stopBgMusic() {
        try {
            if (bgPlayer != null) {
                if (bgPlayer.isPlaying()) bgPlayer.stop();
                bgPlayer.release();
                bgPlayer = null;
            }
        } catch (Exception ignored) {}
    }

    // --- System TTS Speaking ---

    private void speakCurrentLine() {
        if (!ttsInitialized || !speaking || lines == null || currentLineIndex >= lines.length) return;

        String line = lines[currentLineIndex];

        if (line.length() < 3 || line.matches("^[॥।\\|\\s\\d०-९]+$")) {
            currentLineIndex++;
            currentLine.postValue(currentLineIndex);
            if (currentLineIndex < lines.length) {
                try { Thread.sleep(PAUSE_VERSE_END); } catch (InterruptedException ignored) {}
                speakCurrentLine();
            } else {
                speaking = false;
                isPlaying.postValue(false);
                stopBgMusic();
                releaseAudioFocus();
                currentLineIndex = 0;
                currentLine.postValue(0);
                if (eventListener != null) handler.post(() -> eventListener.onCompleted());
            }
            return;
        }

        String processedLine = SanskritPronunciationLexicon.process(line);
        processedLine = processedLine.replaceAll("।।", "। ");

        Bundle params = new Bundle();
        tts.speak(processedLine, TextToSpeech.QUEUE_FLUSH, params, "tts_line_" + currentLineIndex);
    }

    // --- Getters ---

    public LiveData<Boolean> getIsPlaying() { return isPlaying; }
    public LiveData<Integer> getCurrentLine() { return currentLine; }
    public LiveData<Boolean> getIsReady() { return isReady; }
    public LiveData<String> getStatusText() { return statusText; }
    public int getTotalLines() { return lines != null ? lines.length : 0; }
    public int getCurrentLineIndex() { return currentLineIndex; }
    public boolean isSpeaking() { return speaking; }

    /**
     * Get the CloudTtsService for cache management.
     */
    public CloudTtsService getCloudTtsService() { return cloudTtsService; }

    // --- Lifecycle ---

    public void release() {
        stop();
        stopCloudPlayer();
        if (tts != null) { tts.shutdown(); tts = null; }
        cloudTtsExecutor.shutdownNow();
    }
}
